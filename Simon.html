<!doctype html>
<style>
:root {background:#111;color:#eee;white-space:pre}
.Creature {border-radius:5px;
	position:absolute;
 }
.green { background-color: green;}
.red { background-color: red;}
.blue { background-color: blue;}

</style>
<script>

class Creature {
    constructor (community,type,x,y,birthmark) {
        if (['green','red','blue'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Creature type`)
        if (typeof x != 'number') throw new TypeError(`x: ${x} is not a number`)
        if (typeof y != 'number') throw new TypeError(`y: ${y} is not a number`)

        this.community = community
        this.type = type
        this.x = x
        this.y = y
        this.birthmark = birthmark

        this.energy = 9

        community.push(this)
    }

    ///////////////////////////////////////////////
    // Creature-Oriented //////////////////////////
    ///////////////////////////////////////////////
    step () {
        this.move()
        this.eat()
        this.reproduce()
    }
    move () {
        if (this.energy > 0) {
            this.x += Math.random() * (2) - 1
            this.y += Math.random() * (2) - 1
            this.energy -= 0.1
        } 
        else {
            this.energy -= 0.01
        }
        if (this.energy < -10) {
            this.die()
        }
    }
    eat () {
        this.community.filter(
            candidate => candidate != this && Math.abs(candidate.x - this.x) < 2 && Math.abs(candidate.y - this.y) < 2
        ).forEach(prey => {
            prey.die()
            this.energy += 9
        })
    }
    die () {
        let index = this.community.indexOf(this)
        if (index >= 0) {
            this.community.splice(index,1)
        }
        else {
            throw new Error('Creature community corruption error.')
        }
    }
    reproduce () {
        if (this.energy > 10) {
            new Creature(this.community,this.type,this.x+Math.random()*4-2,this.y+Math.random()*4-2,this.energy)
            this.energy -= 10
        }
    }

	Draw (Fragment, i) {
		var ToAdd = document.createElement("div");
		ToAdd.id = 'Creature'+i;
		ToAdd.className = 'Creature '+this.type;
		ToAdd.style.top = this.y+'px';
		ToAdd.style.left = this.x+'px';
		ToAdd.style.width = this.energy+'px';
		ToAdd.style.height = this.energy+'px';

		/*$('<div></div>').attr('id','Creature'+i).addClass('Creature '+this.type).css({'top':(this.y*20)+'px','left':(this.x*20)+'px', /*'z-index':z, 'opacity':  Math.pow(0.5, -z), });*/
//		Fragment.appendChild(ToAdd[0]); // [0] <- this grabs the DOM element which is inside the jquery wrapper.
		Fragment.appendChild(ToAdd);
		return Fragment;
	}
    ///////////////////////////////////////////////

    ///////////////////////////////////////////////
    // Debug //////////////////////////////////////
    ///////////////////////////////////////////////
    toString () {
        return `Behold: ${this.type} creature, at (${Math.round(this.x)}x${Math.round(this.y)}), feeling ${Math.round(this.energy)}.` + (typeof this.birthmark != 'undefined' ? ` ((( ${Math.round(this.birthmark)} )))` : '')
    }
    ///////////////////////////////////////////////
}
Creature.all = []

let mainCommunity = []
for (i = 0; i < 700; i++) {
//setInterval(() => new Creature(
    new
 Creature(
        mainCommunity
       ,['red','green','blue'][Math.floor(Math.random()*3)]
       ,500*Math.random()
       ,500*Math.random()
    )//, 400)
}

Canvas = {};
Canvas.Empty = function ()
{ that = document.body;
	while (that.firstChild) {
	  that.removeChild(that.firstChild);
	}
}
Canvas.Append = function (docFragment)
{
	that = document.body;
	that.appendChild(docFragment);
}

Canvas.redraw = function (Creatures) {
	var docFragment = document.createDocumentFragment();
	for(var i =0; i < Creatures.length; i++)
	 {
	  docFragment = Creatures[i].Draw(docFragment, i);  // (To add conditional statement for drawing only inside the canvas boundaries)
	 }
	Canvas.Empty();
	Canvas.Append(docFragment);
}

Canvas.go = function() {setInterval(() => {
    mainCommunity.forEach(creature => creature.step())
	Canvas.redraw(mainCommunity);
	//    document.body.textContent = mainCommunity.sort((aa,bb) => bb.energy - aa.energy).map(creature => creature.toString()).join('\n')
	},1000/60)
}

setInterval(() => {
    mainCommunity.forEach(creature => creature.step())
	Canvas.redraw(mainCommunity);
	//    document.body.textContent = mainCommunity.sort((aa,bb) => bb.energy - aa.energy).map(creature => creature.toString()).join('\n')
	},1000/60)

</script>
