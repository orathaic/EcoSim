<!doctype html>
<style>
:root {background:#111;color:#eee;white-space:pre}
.Creature {border-radius:5px;
	position:absolute;
 }
.green { background-color: green;}
.red { background-color: red;}
.blue { background-color: blue;}

</style>
<script>
"use strict";
class Creature {
    constructor (community,type,x,y,birthmark) {
        if (['green','red','blue'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Creature type`)
        if (typeof x != 'number') throw new TypeError(`x: ${x} is not a number`)
        if (typeof y != 'number') throw new TypeError(`y: ${y} is not a number`)

        this.community = community
        this.type = type
        this.x = x
        this.y = y
        this.birthmark = birthmark

        this.energy = 9

        community.push(this)
    }

    ///////////////////////////////////////////////
    // Creature-Oriented //////////////////////////
    ///////////////////////////////////////////////
    step () {
        this.move()
        this.eat()
        this.reproduce()
    }

	distanceTo (target) {
		return (Math.pow(Math.abs(target.x - this.x),2) + Math.pow(Math.abs(target.y - this.y),2)) //euclidean distance squared
	}
    move () {
        if (this.energy > 0) {
            this.x += ( Math.random() - 0.5 ) * (4)
            this.y += ( Math.random() - 0.5 ) * (4)
            this.energy -= 0.1
        } 
        else {
            this.energy -= 0.01
        }
        if (this.energy < -10) {
            this.die()
        }
    }
    eat () {
        this.community.filter(
            candidate => Math.abs(candidate.x - this.x) < 2 && Math.abs(candidate.y - this.y) < 2 && candidate.type != this.type &&  candidate != this
        ).forEach(prey => {
            prey.die()
            this.energy += 9
        })
    }
    die () {
        var index = this.community.indexOf(this)
        if (index >= 0) {
            this.community.splice(index,1)
        }
        else {
            throw new Error('Creature community corruption error.')
        }
    }
    reproduce () {
        if (this.energy > 10) {
            new Creature(this.community,this.type,this.x+Math.random()*4-2,this.y+Math.random()*4-2,this.energy)
            this.energy -= 10
        }
    }

	Draw (Fragment, i) {
		var ToAdd = document.createElement("div");
		ToAdd.id = 'Creature'+i;
		ToAdd.className = 'Creature '+this.type;
		ToAdd.style.top = this.y+'px';
		ToAdd.style.left = this.x+'px';
		ToAdd.style.width = this.energy+'px';
		ToAdd.style.height = this.energy+'px';

		/*$('<div></div>').attr('id','Creature'+i).addClass('Creature '+this.type).css({'top':(this.y*20)+'px','left':(this.x*20)+'px', /*'z-index':z, 'opacity':  Math.pow(0.5, -z), });*/
//		Fragment.appendChild(ToAdd[0]); // [0] <- this grabs the DOM element which is inside the jquery wrapper.
		Fragment.appendChild(ToAdd);
		return Fragment;
	}
    ///////////////////////////////////////////////

    ///////////////////////////////////////////////
    // Debug //////////////////////////////////////
    ///////////////////////////////////////////////
    toString () {
        return `Behold: ${this.type} creature, at (${Math.round(this.x)}x${Math.round(this.y)}), feeling ${Math.round(this.energy)}.` + (typeof this.birthmark != 'undefined' ? ` ((( ${Math.round(this.birthmark)} )))` : '')
    }
    ///////////////////////////////////////////////
}

class Plant extends Creature {
    constructor (community,type,x,y,birthmark) {
        if (['green'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Plant-Creature type`)
		
		super(community,type,x,y,birthmark)

        this.energy = 4

//        community.push(this)
    }

    eat () {
			this.energy +=0.5; // mmm solar power
			this.community.filter(
            candidate => Math.abs(candidate.x - this.x) < 12 && Math.abs(candidate.y - this.y) < 12 && candidate.type == 'green' && this.distanceTo(candidate) < 144 && candidate != this
        	).forEach(competition => {
            this.energy -= 0.11
        })

	}

    move () {
        if (this.energy < -10) {
            this.die()
        }
    }
    reproduce () {
        if (this.energy > 12) { 
			{if(Math.random() * 100 > 0.5) 
	            new Plant(this.community,this.type,this.x+(Math.random() - 0.5 )*24,this.y+(Math.random() - 0.5)*24,this.energy)
			else new Creature (this.community,"blue",this.x+(Math.random() - 0.5 )*24,this.y+(Math.random() - 0.5)*24,this.energy)
			}            
			this.energy -= 10
        }
	}

}

var mainCommunity = []

for (var i = 0; i < 7; i++) {
    new Plant(
        mainCommunity
       	//,['red','green','blue'][Math.floor(Math.random()*3)]
		,'green'
       	,500*Math.random()
       	,500*Math.random()
    )
}

var Canvas = {};
Canvas.Empty = function ()
{ var that = document.body;
	while (that.firstChild) {
	  that.removeChild(that.firstChild);
	}
}
Canvas.Append = function (docFragment)
{
	var that = document.body;
	that.appendChild(docFragment);
}

Canvas.redraw = function (Creatures) {
	var docFragment = document.createDocumentFragment();
	for(var i =0, l =Creatures.length; i < l; i++)
	 {
	  docFragment = Creatures[i].Draw(docFragment, i);  // (To add conditional statement for drawing only inside the canvas boundaries)
	 }
	Canvas.Empty();
	Canvas.Append(docFragment);
}

Canvas.go = function() { this.Interval = setInterval(() => {
    mainCommunity.forEach(creature => creature.step())
	},1000/60)

	this.ReDrawInterval = setInterval(() => {
	Canvas.redraw(mainCommunity);
//	    document.body.textContent = mainCommunity.sort((aa,bb) => bb.energy - aa.energy).map(creature => creature.toString()).join('\n')
	},1000/10)
}

Canvas.stop = function() { clearInterval(this.Interval)
							clearInterval(this.ReDrawInterval)
}

//document.addEventListener("keypress", HandleKeyPress());
document.onkeypress = function() { 
		switch(event.which) { 
		case 103: Canvas.go(); break;
		case 115: Canvas.stop(); break;
		default:
		}
};

</script>
