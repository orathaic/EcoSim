<!doctype html>
<style>
:root {background:#111;color:#eee;white-space:pre}
.Creature {border-radius:5px;
	position:absolute;
 }
.green { background-color: green;}
.red { background-color: red;}
.blue { background-color: blue;}

</style>
<script>
"use strict";
class Creature {
    constructor (community,type,x,y,birthmark) {
        if (['green','red','blue'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Creature type`)
        if (typeof x != 'number') throw new TypeError(`x: ${x} is not a number`)
        if (typeof y != 'number') throw new TypeError(`y: ${y} is not a number`)

        this.community = community
        this.type = type
        this.x = x
        this.y = y
        this.birthmark = birthmark

        this.energy = 9

//        community.Creatures.push(this)
    }

    ///////////////////////////////////////////////
    // Creature-Oriented //////////////////////////
    ///////////////////////////////////////////////
    step () { 
        this.move()
        this.eat()
        this.reproduce()
    }

	distanceTo (target) {
		return (Math.pow(Math.abs(target.x - this.x),2) + Math.pow(Math.abs(target.y - this.y),2)) //euclidean distance squared
	}
	Draw (Fragment, i) {
		var ToAdd = document.createElement("div");
		ToAdd.id = 'Creature'+i;
		ToAdd.className = 'Creature '+this.type;
		ToAdd.style.top = (this.y-this.energy/2)+'px';
		ToAdd.style.left = (this.x-this.energy/2)+'px';
		ToAdd.style.width = this.energy+'px';
		ToAdd.style.height = this.energy+'px';

		/*$('<div></div>').attr('id','Creature'+i).addClass('Creature '+this.type).css({'top':(this.y*20)+'px','left':(this.x*20)+'px', /*'z-index':z, 'opacity':  Math.pow(0.5, -z), });*/
//		Fragment.appendChild(ToAdd[0]); // [0] <- this grabs the DOM element which is inside the jquery wrapper.
		Fragment.appendChild(ToAdd);
		return Fragment;
	}
    ///////////////////////////////////////////////

    ///////////////////////////////////////////////
    // Debug //////////////////////////////////////
    ///////////////////////////////////////////////
    toString () {
        return `Behold: ${this.type} creature, at (${Math.round(this.x)}x${Math.round(this.y)}), feeling ${Math.round(this.energy)}.` + (typeof this.birthmark != 'undefined' ? ` ((( ${Math.round(this.birthmark)} )))` : '')
    }
    ///////////////////////////////////////////////
}
class Carnivore extends Creature {
    constructor (community,type,x,y,birthmark) {
        if (['red'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Carnivore-Creature type`)
		
		super(community,type,x,y,birthmark)
        this.energy = 4

        community.Carnivores.push(this)

	}
    move () {
        if (this.energy > 0) {
            this.x += Math.round(( Math.random() - 0.5 ) * (10))
            this.y += Math.round(( Math.random() - 0.5 ) * (10))
            this.energy -= 0.1
        } 
        else {
            this.energy -= 0.1
        }
        if (this.energy < -10) {
            this.die()
        }
    }


    eat () {
        this.community.Herbis.filter(
            candidate => Math.abs(candidate.x - this.x) < 2 && Math.abs(candidate.y - this.y) < 2
        ).forEach(prey => {
            prey.die()
            this.energy += 9
        })
    }
    reproduce () {
        if (this.energy > 10) {
            new Carnivore(this.community,this.type,Math.floor(this.x+Math.random()*4-2),Math.floor(this.y+Math.random()*4-2),this.energy)
            this.energy -= 10
        }
    }
    die () {
        var index = this.community.Carnivores.indexOf(this)
        if (index >= 0) {
            this.community.Carnivores.splice(index,1)
        }
        else {
            throw new Error('Creature community corruption error.')
        }
    }

}

class Herbi extends Creature {
    constructor (community,type,x,y,birthmark) {
        if (['blue'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Herbi-Creature type`)
		
		super(community,type,x,y,birthmark)
        this.energy = 4

        community.Herbis.push(this)

	}
    move () {
        if (this.energy > 0) {
            this.x += Math.round(( Math.random() - 0.5 ) * (10))
            this.y += Math.round(( Math.random() - 0.5 ) * (10))
            this.energy -= 0.1
        } 
        else {
            this.energy -= 0.1
        }
        if (this.energy < -10) {
            this.die()
        }
    }


    eat () {
        this.community.Plants.filter(
            candidate => Math.abs(candidate.x - this.x) < 2 && Math.abs(candidate.y - this.y) < 2
        ).forEach(prey => {
            prey.die()
            this.energy += 9
        })
    }
    reproduce () {
        if (this.energy > 10) {
			if(Math.random() * 100 > 0.2) {
            new Herbi(this.community,this.type,Math.floor(this.x+Math.random()*4-2),Math.floor(this.y+Math.random()*4-2),this.energy)
            this.energy -= 10
			}
			else {new Carnivore(this.community,"red",Math.floor(this.x+Math.random()*4-2),Math.floor(this.y+Math.random()*4-2),this.energy)
			console.log('evolving into a carnivore')			
			}
        }
    }
    die () {
        var index = this.community.Herbis.indexOf(this)
        if (index >= 0) {
            this.community.Herbis.splice(index,1)
        }
        else {
            throw new Error('Creature community corruption error.')
        }
    }

}

class Plant extends Creature {
    constructor (community,type,x,y,birthmark) {
        if (['green'].indexOf(type) < 0) throw new TypeError(`type: ${type} is not a valid Plant-Creature type`)
		
		super(community,type,x,y,birthmark)

        this.energy = 4

        community.Plants.push(this)
    }

    eat () {
			this.energy +=0.5; // mmm solar power
			this.community.Plants.filter(
            candidate => Math.abs(candidate.x - this.x) < 12 && Math.abs(candidate.y - this.y) < 12 && this.distanceTo(candidate) < 144 && candidate != this
        	).forEach(competition => {
            this.energy -= 0.11
        })
	}

    move () {
        if (this.energy < -10) {
            this.die()
        }
    }
    reproduce () {
        if (this.energy > 12) { 
			{if(Math.random() * 100 > 0.5) 
	            new Plant(this.community,this.type,Math.round(this.x+(Math.random() - 0.5 )*36),Math.floor(this.y+(Math.random() - 0.5)*24),this.energy)
			else new Herbi (this.community,"blue",Math.round(this.x+(Math.random() - 0.5 )*36),Math.floor(this.y+(Math.random() - 0.5)*24),this.energy)
			}            
			this.energy -= 10
        }
	}
    die () {
        var index = this.community.Plants.indexOf(this)
        if (index >= 0) {
            this.community.Plants.splice(index,1)
        }
        else {
            throw new Error('Creature community corruption error.')
        }
    }

}

var mainCommunity = {Plants:[], Herbis:[], Carnivores:[]}
	mainCommunity.getCreatures = function() {return this.Plants.concat(this.Herbis).concat(this.Carnivores)}

for (var i = 0; i < 7; i++) {
    new Plant(
        mainCommunity
       	//,['red','green','blue'][Math.floor(Math.random()*3)]
		,'green'
       	,Math.floor(500*Math.random())+50
       	,Math.floor(500*Math.random())+50
    )
}

var Canvas = {};
Canvas.Empty = function ()
{ var that = document.body;
	while (that.firstChild) {
	  that.removeChild(that.firstChild);
	}
}
Canvas.Append = function (docFragment)
{
	var that = document.body;
	that.appendChild(docFragment);
}

Canvas.redraw = function (Creatures) {
	var docFragment = document.createDocumentFragment();
	for(var i =0, l =Creatures.length; i < l; i++)
	 {
	  docFragment = Creatures[i].Draw(docFragment, i);  // (To add conditional statement for drawing only inside the canvas boundaries)
	 }
	Canvas.Empty();
	Canvas.Append(docFragment);
}

Canvas.go = function() { this.Interval = setInterval(() => {
    mainCommunity.getCreatures().forEach(creature => creature.step())
	},1000/60)

	this.ReDrawInterval = setInterval(() => {
	Canvas.redraw( mainCommunity.getCreatures() );
//	    document.body.textContent = mainCommunity.Plants.concat(mainCommunity.Herbis).sort((aa,bb) => bb.energy - aa.energy).map(creature => creature.toString()).join('\n')
	},1000/5)
}

Canvas.stop = function() { clearInterval(this.Interval)
							clearInterval(this.ReDrawInterval)
}

//document.addEventListener("keypress", HandleKeyPress());
document.onkeypress = function() { 
		switch(event.which) { 
		case 103: Canvas.go(); break;
		case 115: Canvas.stop(); break;
		default:
		}
};

</script>
